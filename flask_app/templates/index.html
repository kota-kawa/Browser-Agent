<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ãƒ–ãƒ©ã‚¦ã‚¶åˆ¶å¾¡ãƒ‡ãƒ¢</title>
    <link
      rel="icon"
      type="image/png"
      href="/favicon.png"
      sizes="512x512"
    />
    <link
      rel="icon"
      type="image/x-icon"
      href="/favicon.ico"
    />
    <link
      rel="shortcut icon"
      href="/favicon.ico"
    />
    <link
      rel="apple-touch-icon"
      href="/favicon.png"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;600;700&display=swap"
    />
    <link rel="stylesheet" href="{{ request.url_for('static', path='css/style.css') }}" />
    <script
      src="https://cdn.jsdelivr.net/npm/marked@12.0.2/marked.min.js"
      integrity="sha384-/TQbtLCAerC3jgaim+N78RZSDYV7ryeoBCVqTuzRrFec2akfBkHS7ACQ3PQhvMVi"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"
      integrity="sha384-+VfUPEb0PdtChMwmBcBmykRMDd+v6D/oFmB3rZM/puCMDYcIvF968OimRh4KQY9a"
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <main class="layout">
      <section class="chat-pane" aria-label="ãƒãƒ£ãƒƒãƒˆé ˜åŸŸ">
        <div class="chat-pane__content">
          <header class="chat-header">
            <div class="chat-header-main">
              <h1>ãƒãƒ£ãƒƒãƒˆ</h1>
            </div>
            <div class="chat-header-side">
              <div class="model-selector-group">
                <label for="model-selector" class="model-selector-label">AIãƒ¢ãƒ‡ãƒ«</label>
                <div class="model-selector-wrapper">
                    <select id="model-selector" name="model">
                    </select>
                </div>
              </div>
              <div
                id="connection-indicator"
                class="connection-indicator"
                role="status"
                aria-live="polite"
                data-state="idle"
              >
                <span class="dot" aria-hidden="true"></span>
                <span class="text">æ¥ç¶šã‚’å¾…æ©Ÿã—ã¦ã„ã¾ã™</span>
              </div>
              <div class="chat-controls" role="group" aria-label="ãƒãƒ£ãƒƒãƒˆæ“ä½œ">
                <button
                  type="button"
                  id="pause-button"
                  class="control-button control-button--primary"
                  disabled
                >
                  ä¸€æ™‚åœæ­¢
                </button>
                <button type="button" id="reset-button" class="control-button control-button--ghost">
                  å±¥æ­´ãƒªã‚»ãƒƒãƒˆ
                </button>
              </div>
            </div>
          </header>
          <div class="chat-body">
            <div
              id="messages"
              class="messages"
              aria-live="polite"
              aria-busy="false"
              data-empty-text="ã¾ã ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å…¥åŠ›ã—ã¦ä¼šè©±ã‚’å§‹ã‚ã¾ã—ã‚‡ã†ã€‚"
            ></div>
          </div>
        </div>
        <form id="prompt-form" class="prompt-form" autocomplete="off">
          <label for="prompt-input" class="sr-only">ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ</label>
          <div class="prompt-form__field">
            <textarea
              id="prompt-input"
              name="prompt"
              placeholder="ãƒ–ãƒ©ã‚¦ã‚¶ã«æŒ‡ç¤ºã—ãŸã„å†…å®¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
              rows="3"
              required
            ></textarea>
            <button type="submit" class="submit-button" aria-label="é€ä¿¡">
              <span class="button-icon" aria-hidden="true">â®•</span>
            </button>
          </div>
          <div class="prompt-footer">
            <button
              type="button"
              id="new-task-button"
              class="new-task-button"
              aria-label="æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã¨ã—ã¦é€ä¿¡"
            >
              æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã¨ã—ã¦é€ä¿¡
            </button>
            <span class="hint">Ctrl / âŒ˜ + Enterã§é€ä¿¡</span>
          </div>
        </form>
      </section>
      <section class="browser-pane" aria-label="ãƒ–ãƒ©ã‚¦ã‚¶ç”»é¢">
        <div class="browser-shell">
          <div class="browser-toolbar" role="presentation">
            <div class="browser-toolbar-dots" aria-hidden="true">
              <span></span>
              <span></span>
              <span></span>
            </div>
            <div class="browser-toolbar-title">ãƒªãƒ¢ãƒ¼ãƒˆãƒ–ãƒ©ã‚¦ã‚¶</div>
            <div class="browser-toolbar-url" title="{{ browser_url }}">{{ browser_url }}</div>
          </div>
          <iframe
            src="{{ browser_url }}"
            title="ã‚³ãƒ³ãƒ†ãƒŠå†…ãƒ–ãƒ©ã‚¦ã‚¶"
          ></iframe>
        </div>
      </section>
    </main>
    <script>
      const messagesElement = document.getElementById('messages');
      const statusElement = document.getElementById('status');
      const formElement = document.getElementById('prompt-form');
      const promptInput = document.getElementById('prompt-input');
      const pauseButton = document.getElementById('pause-button');
      const resetButton = document.getElementById('reset-button');
      const newTaskButton = document.getElementById('new-task-button');
      const quickPrompts = document.querySelectorAll('[data-prompt]');
      const connectionIndicator = document.getElementById('connection-indicator');
      const modelSelector = document.getElementById('model-selector');

      let conversation = [];
      let eventSource;
      let isRunning = false;
      let isPaused = false;
      let statusClearTimer;
      let pendingSubmitMode = 'continue';
      let messagesBusy = false;
      let pendingAssistantResponse = false;
      let assistantMessageCount = 0;
      let assistantMessageCountAtSubmit = 0;
      let thinkingShownAt = 0;
      let thinkingHideTimer;
      const MIN_THINKING_MS = 600;
      const DEFAULT_BUSY_TITLE = 'AIãŒè€ƒãˆã¦ã„ã¾ã™';
      const DEFAULT_BUSY_SUB = 'è¦‹ã¤ã‘ãŸæƒ…å ±ã‹ã‚‰å›ç­”ã‚’çµ„ã¿ç«‹ã¦ä¸­';
      const FALLBACK_STEP_DETAIL = 'æ¬¡ã®æ“ä½œã‚’é€²è¡Œä¸­ã§ã™';
      let busyMessageTitle = DEFAULT_BUSY_TITLE;
      let busyMessageSub = DEFAULT_BUSY_SUB;
      let thinkingTitleElement = null;
      let thinkingSubElement = null;
      let stepInProgress = false;
      let currentStepNumber = null;
      let currentStepDetail = '';

      function setStatus(message, variant = 'info') {
        if (!statusElement) {
          return;
        }
        if (statusClearTimer) {
          clearTimeout(statusClearTimer);
          statusClearTimer = undefined;
        }
        statusElement.textContent = message;
        statusElement.dataset.variant = message ? variant : 'muted';
        if (message && (variant === 'info' || variant === 'success')) {
          statusClearTimer = window.setTimeout(() => {
            statusElement.textContent = '';
            statusElement.dataset.variant = 'muted';
            statusClearTimer = undefined;
          }, 5000);
        }
      }

      let thinkingMessageElement = null;

      function createThinkingMessage() {
        const wrapper = document.createElement('div');
        wrapper.className = 'msg system compact assistant pending thinking';
        wrapper.id = 'thinking-message';

        const header = document.createElement('div');
        header.className = 'thinking-header';

        const orb = document.createElement('span');
        orb.className = 'thinking-orb';
        orb.setAttribute('aria-hidden', 'true');
        header.appendChild(orb);

        const labels = document.createElement('span');
        labels.className = 'thinking-labels';

        const title = document.createElement('span');
        title.className = 'thinking-title';
        title.textContent = busyMessageTitle;
        labels.appendChild(title);

        const sub = document.createElement('span');
        sub.className = 'thinking-sub';
        sub.textContent = busyMessageSub;
        labels.appendChild(sub);

        header.appendChild(labels);
        wrapper.appendChild(header);

        const time = document.createElement('span');
        time.className = 'msg-time';
        const now = new Date();
        time.textContent = now.toLocaleString('ja-JP', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        }).replace(/\//g, '/');
        wrapper.appendChild(time);

        thinkingTitleElement = title;
        thinkingSubElement = sub;

        return wrapper;
      }

      function updateThinkingMessageContent(title, sub) {
        busyMessageTitle = title || DEFAULT_BUSY_TITLE;
        busyMessageSub = sub || DEFAULT_BUSY_SUB;
        if (thinkingTitleElement) {
          thinkingTitleElement.textContent = busyMessageTitle;
        }
        if (thinkingSubElement) {
          thinkingSubElement.textContent = busyMessageSub;
        }
      }

      function ensureThinkingMessage() {
        if (!messagesElement) {
          return;
        }
        if (!thinkingMessageElement) {
          thinkingMessageElement = createThinkingMessage();
        }
        if (!thinkingMessageElement.isConnected) {
          messagesElement.appendChild(thinkingMessageElement);
        }
      }

      function ensureThinkingMessageAtEnd() {
        if (!messagesBusy || !messagesElement) {
          return;
        }
        ensureThinkingMessage();
        if (thinkingMessageElement && messagesElement.lastElementChild !== thinkingMessageElement) {
          thinkingMessageElement.remove();
          messagesElement.appendChild(thinkingMessageElement);
        }
      }

      function removeThinkingMessage() {
        if (thinkingMessageElement && thinkingMessageElement.isConnected) {
          thinkingMessageElement.remove();
        }
        thinkingMessageElement = null;
        thinkingTitleElement = null;
        thinkingSubElement = null;
        thinkingShownAt = 0;
      }

      function setMessagesBusy(isBusy) {
        if (!messagesElement) {
          return;
        }
        if (thinkingHideTimer) {
          clearTimeout(thinkingHideTimer);
          thinkingHideTimer = undefined;
        }
        const wasBusy = messagesBusy;
        messagesBusy = isBusy;
        if (isBusy) {
          messagesElement.setAttribute('aria-busy', 'true');
          if (!wasBusy) {
            thinkingShownAt = Date.now();
          }
          ensureThinkingMessage();
          messagesElement.scrollTop = messagesElement.scrollHeight;
          return;
        }
        messagesElement.setAttribute('aria-busy', 'false');
        if (!thinkingMessageElement) {
          thinkingShownAt = 0;
          return;
        }
        const elapsed = Date.now() - (thinkingShownAt || Date.now());
        const remaining = Math.max(0, MIN_THINKING_MS - elapsed);
        if (remaining > 0) {
          thinkingHideTimer = window.setTimeout(() => {
            thinkingHideTimer = undefined;
            if (!messagesBusy) {
              removeThinkingMessage();
            }
          }, remaining);
        } else {
          removeThinkingMessage();
        }
      }

      function setConnectionState(state) {
        if (!connectionIndicator) {
          return;
        }
        connectionIndicator.dataset.state = state;
        const textElement = connectionIndicator.querySelector('.text');
        let message = 'æ¥ç¶šã‚’å¾…æ©Ÿã—ã¦ã„ã¾ã™';
        if (state === 'connected') {
          message = 'ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ä¸­';
        } else if (state === 'connecting') {
          message = 'æ¥ç¶šä¸­â€¦';
        } else if (state === 'disconnected') {
          message = 'å†æ¥ç¶šã‚’è©¦è¡Œä¸­';
        }
        if (textElement) {
          textElement.textContent = message;
        }
      }

      function updateEmptyState() {
        if (!messagesElement) {
          return;
        }
        if (messagesElement.children.length === 0) {
          messagesElement.classList.add('is-empty');
        } else {
          messagesElement.classList.remove('is-empty');
        }
      }

      function extractStepInfo(content) {
        if (!content || typeof content !== 'string') {
          return null;
        }
        const lines = content
          .split('\n')
          .map((line) => line.trim())
          .filter(Boolean);
        if (!lines.length) {
          return null;
        }
        const match = lines[0].match(/^ã‚¹ãƒ†ãƒƒãƒ—(\d+)/);
        if (!match) {
          return null;
        }
        const stepNumber = Number(match[1]);
        const currentStatus = lines.find((line) => line.startsWith('ç¾åœ¨ã®çŠ¶æ³:'));
        const nextGoal = lines.find((line) => line.startsWith('æ¬¡ã®ç›®æ¨™:'));
        const actionLine = lines.find((line) => line.startsWith('ã‚¢ã‚¯ã‚·ãƒ§ãƒ³:'));
        const evaluationLine = lines.find((line) => line.startsWith('è©•ä¾¡:'));
        let detail = '';
        if (currentStatus) {
          detail = currentStatus.replace('ç¾åœ¨ã®çŠ¶æ³:', '').trim();
        } else if (nextGoal) {
          detail = `æ¬¡ã®ç›®æ¨™: ${nextGoal.replace('æ¬¡ã®ç›®æ¨™:', '').trim()}`;
        } else if (actionLine) {
          detail = `æ“ä½œ: ${actionLine.replace('ã‚¢ã‚¯ã‚·ãƒ§ãƒ³:', '').trim()}`;
        } else if (evaluationLine) {
          detail = `è©•ä¾¡: ${evaluationLine.replace('è©•ä¾¡:', '').trim()}`;
        }
        return { stepNumber, detail };
      }

      function isRunSummaryMessage(content) {
        if (!content || typeof content !== 'string') {
          return false;
        }
        if (!/^[âœ…âš ï¸â„¹ï¸]/.test(content)) {
          return false;
        }
        return content.includes('ã‚¹ãƒ†ãƒƒãƒ—ã§ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå®Ÿè¡Œã•ã‚Œã¾ã—ãŸ');
      }

      function updateStepActivity(stepInfo) {
        if (!stepInfo) {
          return;
        }
        stepInProgress = true;
        currentStepNumber = stepInfo.stepNumber;
        currentStepDetail = stepInfo.detail || '';
        updateBusyState();
      }

      function clearStepActivity() {
        stepInProgress = false;
        currentStepNumber = null;
        currentStepDetail = '';
        if (!pendingAssistantResponse) {
          updateBusyState();
        }
      }

      function updateBusyState() {
        const shouldBusy = pendingAssistantResponse || stepInProgress;
        if (shouldBusy) {
          if (stepInProgress && currentStepNumber) {
            const detail = currentStepDetail || FALLBACK_STEP_DETAIL;
            updateThinkingMessageContent(`ã‚¹ãƒ†ãƒƒãƒ—${currentStepNumber}ã‚’å®Ÿè¡Œã—ã¦ã„ã¾ã™`, detail);
          } else {
            updateThinkingMessageContent(DEFAULT_BUSY_TITLE, DEFAULT_BUSY_SUB);
          }
        }
        setMessagesBusy(shouldBusy);
      }

      function findLastStepInfo(messages) {
        if (!Array.isArray(messages)) {
          return null;
        }
        for (let index = messages.length - 1; index >= 0; index -= 1) {
          const message = messages[index];
          if (!message || message.role !== 'assistant') {
            continue;
          }
          if (isRunSummaryMessage(message.content)) {
            return null;
          }
          const stepInfo = extractStepInfo(message.content);
          if (stepInfo) {
            return stepInfo;
          }
        }
        return null;
      }

      function countAssistantMessages(messages) {
        let count = 0;
        messages.forEach((message) => {
          if (message && message.role === 'assistant') {
            count += 1;
          }
        });
        return count;
      }

      function resolvePendingAssistantResponse() {
        if (!pendingAssistantResponse) {
          return;
        }
        if (assistantMessageCount > assistantMessageCountAtSubmit) {
          pendingAssistantResponse = false;
          updateBusyState();
        }
      }

      function encodeModelSelection(selection) {
        if (!selection || !selection.provider || !selection.model) {
          return null;
        }
        return JSON.stringify({ provider: selection.provider, model: selection.model });
      }

      setStatus('', 'muted');
      setConnectionState('idle');
      updateEmptyState();

      async function loadModels(preferredSelection) {
        if (!modelSelector) {
          return;
        }
        try {
          const response = await fetch('/api/models');
          if (!response.ok) {
            throw new Error('ãƒ¢ãƒ‡ãƒ«ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
          }
          const data = await response.json();
          const models = Array.isArray(data) ? data : Array.isArray(data.models) ? data.models : [];
          const current = !Array.isArray(data) && typeof data.current === 'object' ? data.current : null;
          const preferred = encodeModelSelection(preferredSelection);

          modelSelector.innerHTML = '';
          models.forEach(model => {
            const option = document.createElement('option');
            option.value = JSON.stringify({ provider: model.provider, model: model.model });
            option.textContent = model.label;
            modelSelector.appendChild(option);
          });

          const desired = preferred || encodeModelSelection(current);
          const hasDesired = desired && Array.from(modelSelector.options).some(opt => opt.value === desired);

          if (hasDesired) {
            modelSelector.value = desired;
          } else if (modelSelector.options.length) {
            modelSelector.selectedIndex = 0;
          }
        } catch (error) {
          setStatus(error.message, 'error');
        }
      }

      async function applyModelSelection(selection) {
        try {
          const response = await fetch('/model_settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(selection),
          });
          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || 'ãƒ¢ãƒ‡ãƒ«è¨­å®šã®é©ç”¨ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
          }
          setStatus(`ãƒ¢ãƒ‡ãƒ«ã‚’ ${selection.label || selection.model} ã«å¤‰æ›´ã—ã¾ã—ãŸã€‚`, 'success');
        } catch (error) {
          setStatus(error.message, 'error');
        }
      }

      if (modelSelector) {
        modelSelector.addEventListener('change', () => {
          try {
            const selectedOption = modelSelector.options[modelSelector.selectedIndex];
            const selection = JSON.parse(selectedOption.value);
            selection.label = selectedOption.textContent;
            applyModelSelection(selection);
          } catch (error) {
            setStatus('ãƒ¢ãƒ‡ãƒ«è¨­å®šã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚', 'error');
          }
        });
      }

      function renderMessageContent(element, content) {
        if (!element) {
          return;
        }
        const text = typeof content === 'string' ? content : '';
        if (window.marked) {
          const markedOptions = {
            breaks: true,
            gfm: true,
          };
          const parsed = window.marked.parse(text, markedOptions);
          if (window.DOMPurify) {
            element.innerHTML = window.DOMPurify.sanitize(parsed, {
              USE_PROFILES: { html: true },
            });
          } else {
            element.innerHTML = parsed;
          }
        } else {
          element.textContent = text;
        }
      }

      function formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        if (Number.isNaN(date.getTime())) {
          return { text: '', iso: '' };
        }
        return {
          iso: date.toISOString(),
          text: date.toLocaleString('ja-JP', {
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
          }),
        };
      }

      function applyTimestamp(element, timestamp) {
        if (!element) {
          return;
        }
        const formatted = formatTimestamp(timestamp);
        element.textContent = formatted.text;
        if (formatted.iso) {
          element.dateTime = formatted.iso;
        } else {
          element.removeAttribute('datetime');
        }
      }

      function createMessageElement(message) {
        const wrapper = document.createElement('article');
        wrapper.className = `message ${message.role}`;
        wrapper.dataset.id = message.id;

        const header = document.createElement('header');
        header.className = 'message__header';

        const title = document.createElement('div');
        title.className = 'message__title';

        const avatar = document.createElement('span');
        avatar.className = 'message__avatar';
        avatar.setAttribute('aria-hidden', 'true');
        avatar.textContent = message.role === 'assistant' ? 'ğŸ¤–' : 'ğŸ§‘';
        title.appendChild(avatar);

        const badge = document.createElement('span');
        badge.className = 'message__badge';
        badge.textContent = message.role === 'assistant' ? 'LLM' : 'ãƒ¦ãƒ¼ã‚¶ãƒ¼';
        title.appendChild(badge);

        header.appendChild(title);

        const timestamp = document.createElement('time');
        timestamp.className = 'message__timestamp';
        applyTimestamp(timestamp, message.timestamp);
        header.appendChild(timestamp);

        wrapper.appendChild(header);

        const body = document.createElement('div');
        body.className = 'message__body';

        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        renderMessageContent(bubble, message.content);
        body.appendChild(bubble);

        wrapper.appendChild(body);

        return wrapper;
      }

      function updateMessageElement(element, message) {
        const bubble = element.querySelector('.bubble');
        if (bubble) {
          renderMessageContent(bubble, message.content);
        }
        const timestamp = element.querySelector('.message__timestamp');
        applyTimestamp(timestamp, message.timestamp);
      }

      function renderMessages(messages) {
        const existingThinking = thinkingMessageElement;
        if (existingThinking && existingThinking.isConnected) {
          existingThinking.remove();
        }
        messagesElement.innerHTML = '';
        messages.forEach((message) => {
          messagesElement.appendChild(createMessageElement(message));
        });
        if (messagesBusy) {
          thinkingMessageElement = existingThinking || createThinkingMessage();
          if (!thinkingMessageElement.isConnected) {
            messagesElement.appendChild(thinkingMessageElement);
          }
        } else {
          thinkingMessageElement = null;
          thinkingTitleElement = null;
          thinkingSubElement = null;
        }
        messagesElement.scrollTop = messagesElement.scrollHeight;
        updateEmptyState();
        assistantMessageCount = countAssistantMessages(messages);
        const lastStepInfo = findLastStepInfo(messages);
        if (lastStepInfo && (isRunning || pendingAssistantResponse)) {
          stepInProgress = true;
          currentStepNumber = lastStepInfo.stepNumber;
          currentStepDetail = lastStepInfo.detail || '';
        } else if (!isRunning && !pendingAssistantResponse) {
          stepInProgress = false;
          currentStepNumber = null;
          currentStepDetail = '';
        }
        resolvePendingAssistantResponse();
        updateBusyState();
        ensureThinkingMessageAtEnd();
      }

      function appendOrUpdateMessage(message) {
        if (!message || typeof message.id === 'undefined') {
          return;
        }
        const existingIndex = conversation.findIndex((item) => item.id === message.id);
        if (existingIndex >= 0) {
          conversation[existingIndex] = message;
          const element = messagesElement.querySelector(`[data-id="${message.id}"]`);
          if (element) {
            updateMessageElement(element, message);
          } else {
            renderMessages(conversation);
          }
        } else {
          conversation.push(message);
          messagesElement.appendChild(createMessageElement(message));
          messagesElement.scrollTop = messagesElement.scrollHeight;
        }
        updateEmptyState();
        assistantMessageCount = countAssistantMessages(conversation);
        if (message.role === 'assistant') {
          const stepInfo = extractStepInfo(message.content);
          if (stepInfo) {
            updateStepActivity(stepInfo);
          } else if (isRunSummaryMessage(message.content)) {
            clearStepActivity();
          }
          if (existingIndex < 0) {
            resolvePendingAssistantResponse();
          }
        }
        ensureThinkingMessageAtEnd();
      }

      function updatePauseButtonState() {
        if (pauseButton) {
          if (!isRunning) {
            pauseButton.disabled = true;
            pauseButton.textContent = 'ä¸€æ™‚åœæ­¢';
          } else {
            pauseButton.disabled = false;
            pauseButton.textContent = isPaused ? 'å†é–‹' : 'ä¸€æ™‚åœæ­¢';
          }
        }
        if (newTaskButton) {
          const sending = formElement.classList.contains('is-sending');
          newTaskButton.disabled = isRunning || sending;
        }
      }

      async function loadHistory() {
        try {
          const response = await fetch('/api/history');
          if (!response.ok) {
            throw new Error('å±¥æ­´ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
          }
          const data = await response.json();
          conversation = data.messages || [];
          renderMessages(conversation);
          setStatus('', 'muted');
        } catch (error) {
          setStatus(error.message, 'error');
        }
      }

      function handleResetEvent() {
        conversation = [];
        renderMessages(conversation);
        setStatus('å±¥æ­´ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚', 'success');
        pendingAssistantResponse = false;
        assistantMessageCount = 0;
        assistantMessageCountAtSubmit = 0;
        clearStepActivity();
        updateBusyState();
        updatePauseButtonState();
        setConnectionState('connected');
        loadHistory();
      }

      function setupEventStream() {
        if (eventSource) {
          eventSource.close();
        }
        setConnectionState('connecting');
        setStatus('ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«æ¥ç¶šã—ã¦ã„ã¾ã™â€¦', 'progress');
        eventSource = new EventSource('/api/stream');
        eventSource.onopen = () => {
          setConnectionState('connected');
          setStatus('ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ã¨åŒæœŸã—ã¾ã—ãŸã€‚', 'success');
        };
        eventSource.onmessage = (event) => {
          try {
            const payload = JSON.parse(event.data);
            if (payload.type === 'message' && payload.payload) {
              appendOrUpdateMessage(payload.payload);
            } else if (payload.type === 'update' && payload.payload) {
              appendOrUpdateMessage(payload.payload);
            } else if (payload.type === 'reset') {
              handleResetEvent();
            } else if (payload.type === 'model' && payload.payload) {
              loadModels(payload.payload);
              const updatedLabel = payload.payload.label || payload.payload.model;
              if (updatedLabel) {
                setStatus(`ãƒ¢ãƒ‡ãƒ«è¨­å®šãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸ: ${updatedLabel}`, 'info');
              } else {
                setStatus('ãƒ¢ãƒ‡ãƒ«è¨­å®šãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸã€‚', 'info');
              }
            } else if (payload.type === 'status' && payload.payload) {
              const statusPayload = payload.payload || {};
              isRunning = false;
              isPaused = false;
              updatePauseButtonState();
              if (statusPayload.run_summary) {
                // Suppress the top completion banner for finished tasks.
              }
              pendingAssistantResponse = false;
              clearStepActivity();
              updateBusyState();
            }
          } catch (error) {
            console.error('ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ', error);
          }
        };
        eventSource.onerror = () => {
          setConnectionState('disconnected');
          setStatus('ã‚¹ãƒˆãƒªãƒ¼ãƒ æ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸã€‚å†æ¥ç¶šã‚’è©¦ã¿ã¦ã„ã¾ã™â€¦', 'warning');
          eventSource.close();
          setTimeout(setupEventStream, 2000);
        };
      }

      formElement.addEventListener('submit', async (event) => {
        event.preventDefault();
        const mode = pendingSubmitMode;
        pendingSubmitMode = 'continue';
        const isNewTaskSubmission = mode === 'new-task';
        const rawPrompt = promptInput.value;
        const prompt = rawPrompt.trim();
        if (!prompt) {
          setStatus('ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚', 'warning');
          return;
        }

        const submittedPromptValue = rawPrompt;
        formElement.classList.add('is-sending');
        setStatus(
          isNewTaskSubmission
            ? 'æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã¨ã—ã¦ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«æŒ‡ç¤ºã‚’é€ä¿¡ã—ã¦ã„ã¾ã™â€¦'
            : 'ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«æŒ‡ç¤ºã‚’é€ä¿¡ã—ã¦ã„ã¾ã™â€¦',
          'progress',
        );
        isRunning = true;
        isPaused = false;
        updatePauseButtonState();
        if (isNewTaskSubmission) {
          clearStepActivity();
        }
        pendingAssistantResponse = true;
        assistantMessageCountAtSubmit = assistantMessageCount;
        updateBusyState();

        promptInput.value = '';
        promptInput.focus();

        let shouldContinueRunning = false;

        try {
          if (newTaskButton) {
            newTaskButton.disabled = true;
          }
          const response = await fetch('/api/chat', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(
              isNewTaskSubmission ? { prompt, new_task: true } : { prompt },
            ),
          });

          const data = await response.json().catch(() => ({}));
          if (!response.ok) {
            const message = data.error || 'LLMã¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
            throw new Error(message);
          }

          if (Array.isArray(data.messages)) {
            conversation = data.messages;
            renderMessages(conversation);
          }
          const agentStillRunning = response.status === 202 || data.agent_running === true;
          shouldContinueRunning = Boolean(agentStillRunning);
          if (agentStillRunning) {
            const runSummary = data.run_summary || 'ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå®Ÿè¡Œã‚’ç¶™ç¶šã—ã¦ã„ã¾ã™ã€‚';
            setStatus(runSummary, 'progress');
          } else {
            setStatus('', 'muted');
          }
        } catch (error) {
          if (!promptInput.value.trim()) {
            promptInput.value = submittedPromptValue;
            if (typeof promptInput.setSelectionRange === 'function') {
              const length = promptInput.value.length;
              promptInput.setSelectionRange(length, length);
            }
            promptInput.focus();
          }
          setStatus(error.message || 'ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚', 'error');
          pendingAssistantResponse = false;
          clearStepActivity();
          updateBusyState();
          shouldContinueRunning = false;
        } finally {
          formElement.classList.remove('is-sending');
          isRunning = shouldContinueRunning;
          if (!shouldContinueRunning) {
            isPaused = false;
          }
          updatePauseButtonState();
          updateBusyState();
        }
      });

      if (pauseButton) {
        pauseButton.addEventListener('click', async () => {
          if (pauseButton.disabled) {
            return;
          }
          pauseButton.disabled = true;
          const endpoint = isPaused ? '/api/resume' : '/api/pause';
          try {
            const response = await fetch(endpoint, { method: 'POST' });
            const data = await response.json().catch(() => ({}));
            if (!response.ok) {
              const message = data.error || (isPaused ? 'å†é–‹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚' : 'ä¸€æ™‚åœæ­¢ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
              throw new Error(message);
            }
            isPaused = !isPaused;
            setStatus(
              isPaused ? 'ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ä¸€æ™‚åœæ­¢ã—ã¾ã—ãŸã€‚' : 'ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å†é–‹ã—ã¾ã—ãŸã€‚',
              'info',
            );
          } catch (error) {
            setStatus(error.message || 'æ“ä½œã«å¤±æ•—ã—ã¾ã—ãŸã€‚', 'error');
          } finally {
            updatePauseButtonState();
          }
        });
      }

      if (newTaskButton) {
        newTaskButton.addEventListener('click', () => {
          if (newTaskButton.disabled) {
            return;
          }
          if (!promptInput.value.trim()) {
            setStatus('æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã®æŒ‡ç¤ºã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚', 'warning');
            promptInput.focus();
            return;
          }
          pendingSubmitMode = 'new-task';
          if (typeof formElement.requestSubmit === 'function') {
            formElement.requestSubmit();
          } else {
            formElement.submit();
          }
        });
      }

      if (resetButton) {
        resetButton.addEventListener('click', async () => {
          const confirmed = window.confirm('ä¼šè©±å±¥æ­´ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ');
          if (!confirmed) {
            return;
          }
          resetButton.disabled = true;
          try {
            const response = await fetch('/api/reset', { method: 'POST' });
            const data = await response.json().catch(() => ({}));
            if (!response.ok) {
              const message = data.error || 'å±¥æ­´ã®ãƒªã‚»ãƒƒãƒˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
              throw new Error(message);
            }
            conversation = data.messages || [];
            renderMessages(conversation);
            setStatus('å±¥æ­´ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚', 'success');
            isRunning = false;
            isPaused = false;
            updatePauseButtonState();
          } catch (error) {
            setStatus(error.message || 'å±¥æ­´ã®ãƒªã‚»ãƒƒãƒˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚', 'error');
          } finally {
            resetButton.disabled = false;
          }
        });
      }

      if (promptInput) {
        promptInput.addEventListener('keydown', (event) => {
          if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {
            event.preventDefault();
            if (formElement && typeof formElement.requestSubmit === 'function') {
              formElement.requestSubmit();
            } else if (formElement) {
              formElement.submit();
            }
          }
        });
      }

      if (quickPrompts.length > 0) {
        quickPrompts.forEach((button) => {
          button.addEventListener('click', () => {
            const preset = button.dataset.prompt || '';
            if (preset && promptInput) {
              promptInput.value = preset;
              promptInput.focus();
              setStatus('ã‚¯ã‚¤ãƒƒã‚¯ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›ã—ã¾ã—ãŸã€‚ç·¨é›†ã—ã¦é€ä¿¡ã§ãã¾ã™ã€‚', 'info');
            }
          });
        });
      }

      setupEventStream();
      loadHistory();
      loadModels();
      updatePauseButtonState();

      // Ensure the embedded noVNC session fills the browser pane
      const browserIframe = document.querySelector('.browser-pane iframe');
      if (browserIframe) {
        const shell = document.querySelector('.browser-shell');
        const toolbar = shell?.querySelector('.browser-toolbar');

        const syncIframeHeight = () => {
          if (!shell) {
            return;
          }
          const toolbarHeight = toolbar?.offsetHeight ?? 0;
          const nextHeight = Math.max(shell.clientHeight - toolbarHeight, 0);
          browserIframe.style.height = `${nextHeight}px`;
        };

        if (shell) {
          if (typeof ResizeObserver !== 'undefined') {
            const resizeObserver = new ResizeObserver(syncIframeHeight);
            resizeObserver.observe(shell);
          } else {
            window.addEventListener('resize', syncIframeHeight);
          }
        }

        syncIframeHeight();
      }
    </script>
  </body>
</html>
